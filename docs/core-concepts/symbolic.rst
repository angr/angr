Symbolic Execution
==================

Symbolic execution is a program analysis technique used to explore multiple execution paths of a program simultaneously. Unlike normal execution, which runs the program with specific inputs, symbolic execution treats inputs as symbolic variables rather than concrete values. This means the execution can represent a wide range of inputs with symbolic expressions. Symbolic execution allows, at a time in emulation, to determine for a branch all conditions necessary to take a branch or not. Every variable is represented as a symbolic value, and each branch as a constraint. Thus, symbolic execution allows us to see which conditions allow the program to go from point A to point B by resolving these constraints. The execution paths are then analyzed by solving constraints generated by these symbolic expressions, allowing the discovery of bugs and vulnerabilities that might be missed in standard testing.


Example:
--------

Consider the following simple program in Python:

.. code-block:: python

   def check_value(x):
       if x > 10:
           return "Greater"
       else:
           return "Lesser or Equal"

In normal execution, if `x` is set to 5, the program will follow the path where `x <= 10` and return "Lesser or Equal". In symbolic execution, `x` is treated as a symbolic variable, `X`. The execution engine explores both paths:
   
   - Path 1: `X > 10` leading to the result "Greater"
   - Path 2: `X <= 10` leading to the result "Lesser or Equal"

Constraints for both paths are generated and solved to understand all possible behaviors of the program.




In software verification, it helps ensure that the code behaves as expected across all possible inputs and states. For security analysis, symbolic execution can uncover vulnerabilities such as input validation errors, which could be exploited by attackers. Additionally, in automated testing, it aids in generating comprehensive test cases that cover edge cases and rare execution paths, enhancing the robustness and security of software systems. Overall, symbolic execution provides a powerful means to rigorously analyze and improve software and firmware reliability.
