from collections.abc import Sequence

class State: ...

def alloc(
    uc: object,
    cache_key: int,
    simos: object,
    handle_symbolic_addrs: bool,
    handle_symb_cond: bool,
    handle_symb_syscalls: bool,
) -> State: ...
def dealloc(state: State) -> None: ...
def bbl_addrs(state: State) -> Sequence[int]: ...
def stack_pointers(state: State) -> Sequence[int]: ...
def bbl_addr_count(state: State) -> int: ...
def syscall_count(state: State) -> int: ...
def hook(state: State) -> None: ...
def unhook(state: State) -> None: ...
def start(state: State, pc: int, step: int) -> int: ...
def stop(state: State, reason: int) -> None: ...
def sync(state: State) -> object: ...
def step(state: State) -> int: ...
def set_last_block_details(state: State, block_addr: int, curr_count: int, total_count: int) -> None: ...
def set_random_syscall_data(state: State, values: Sequence[int], sizes: Sequence[int], count: int) -> None: ...
def set_stops(state: State, count: int, stops: Sequence[int]) -> None: ...
def activate_page(state: State, address: int, taint: bytes, data: bytes) -> None: ...
def executed_pages(state: State) -> int: ...
def get_stop_details(state: State) -> object: ...
def symbolic_register_data(state: State, count: int, offsets: Sequence[int]) -> None: ...
def get_symbolic_registers(state: State, output: Sequence[int]) -> int: ...
def enable_symbolic_reg_tracking(state: State, guest: int, archinfo: int) -> None: ...
def disable_symbolic_reg_tracking(state: State) -> None: ...
def is_interrupt_handled(state: State) -> bool: ...
def set_cgc_syscall_details(
    state: State,
    transmit_num: int,
    transmit_bbl: int,
    receive_num: int,
    receive_bbl: int,
    receive_size: int,
    random_num: int,
    random_bbl: int,
) -> None: ...
def process_transmit(state: State, num: int) -> object: ...
def set_fd_bytes(state: State, fd: int, input: bytes, taints: bytes, len: int, read_pos: int) -> None: ...
def cache_page(state: State, address: int, length: int, bytes: bytes, permissions: int) -> bool: ...
def uncache_pages_touching_region(state: State, address: int, length: int) -> None: ...
def clear_page_cache(state: State) -> None: ...
def set_tracking(state: State, track_bbls: bool, track_stack: bool) -> None: ...
def in_cache(state: State, address: int) -> bool: ...
def set_map_callback(state: State, cb: object) -> None: ...
def set_artificial_registers(state: State, offsets: Sequence[int], count: int) -> None: ...
def set_vex_to_unicorn_reg_mappings(
    state: State, vex_offsets: Sequence[int], unicorn_ids: Sequence[int], reg_sizes: Sequence[int], count: int
) -> None: ...
def set_cpu_flags_details(
    state: State, flag_vex_id: Sequence[int], uc_reg_id: Sequence[int], bitmasks: Sequence[int], count: int
) -> None: ...
def set_register_blacklist(state: State, reg_list: Sequence[int], count: int) -> None: ...
def set_vex_cc_reg_data(state: State, reg_offsets: Sequence[int], reg_sizes: Sequence[int], count: int) -> None: ...
def get_count_of_blocks_with_symbolic_vex_stmts(state: State) -> int: ...
def get_details_of_blocks_with_symbolic_vex_stmts(state: State, ret_block_details: object) -> None: ...
def get_count_of_writes_to_reexecute(state: State) -> int: ...
def get_concrete_writes_to_reexecute(state: State, addrs: Sequence[int], values: bytes) -> None: ...
def set_fp_regs_fp_ops_vex_codes(
    state: State, start_offset: int, size: int, ops: Sequence[int], op_count: int
) -> None: ...
