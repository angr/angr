from collections.abc import Sequence
from enum import Enum

class State: ...

class SimOS(Enum):
    CGC: int
    LINUX: int
    OTHER: int

class StopReason(Enum):
    NORMAL: int
    STOPPOINT: int
    ERROR: int
    SYSCALL: int
    EXECNONE: int
    ZEROPAGE: int
    NOSTART: int
    SEGFAULT: int
    ZERO_DIV: int
    NODECODE: int
    HLT: int
    VEX_LIFT_FAILED: int
    SYMBOLIC_PC: int
    SYMBOLIC_READ_ADDR: int
    SYMBOLIC_READ_SYMBOLIC_TRACKING_DISABLED: int
    SYMBOLIC_WRITE_ADDR: int
    SYMBOLIC_BLOCK_EXIT_CONDITION: int
    SYMBOLIC_BLOCK_EXIT_TARGET: int
    UNSUPPORTED_STMT_PUTI: int
    UNSUPPORTED_STMT_STOREG: int
    UNSUPPORTED_STMT_LOADG: int
    UNSUPPORTED_STMT_CAS: int
    UNSUPPORTED_STMT_LLSC: int
    UNSUPPORTED_STMT_DIRTY: int
    UNSUPPORTED_STMT_UNKNOWN: int
    UNSUPPORTED_EXPR_GETI: int
    UNSUPPORTED_EXPR_UNKNOWN: int
    UNKNOWN_MEMORY_WRITE_SIZE: int
    SYSCALL_ARM: int
    X86_CPUID: int

class StopDetails:
    stop_reason: int
    block_addr: int
    block_size: int

class RegisterValue:
    offset: int
    # value: bytes  # Not exposed due to pybind11 limitation
    size: int

class SymVexStmtDetails:
    stmt_idx: int
    has_memory_dep: bool
    memory_values: object  # pointer/array, not directly exposed
    memory_values_count: int

class SymBlockDetailsRet:
    block_addr: int
    block_size: int
    block_trace_ind: int
    has_symbolic_exit: bool
    symbolic_stmts: object  # pointer/array, not directly exposed
    symbolic_stmts_count: int
    register_values: object  # pointer/array, not directly exposed
    register_values_count: int

class TransmitRecord:
    fd: int
    data: object  # pointer/array, not directly exposed
    count: int

def alloc(
    uc: object,
    cache_key: int,
    simos: object,
    handle_symbolic_addrs: bool,
    handle_symb_cond: bool,
    handle_symb_syscalls: bool,
) -> State: ...
def dealloc(state: State) -> None: ...
def bbl_addrs(state: State) -> Sequence[int]: ...
def stack_pointers(state: State) -> Sequence[int]: ...
def bbl_addr_count(state: State) -> int: ...
def syscall_count(state: State) -> int: ...
def hook(state: State) -> None: ...
def unhook(state: State) -> None: ...
def start(state: State, pc: int, step: int) -> int: ...
def stop(state: State, reason: int) -> None: ...
def sync(state: State) -> object: ...
def step(state: State) -> int: ...
def set_last_block_details(state: State, block_addr: int, curr_count: int, total_count: int) -> None: ...
def set_random_syscall_data(state: State, values: Sequence[int], sizes: Sequence[int], count: int) -> None: ...
def set_stops(state: State, count: int, stops: Sequence[int]) -> None: ...
def activate_page(state: State, address: int, taint: bytes, data: bytes) -> None: ...
def executed_pages(state: State) -> int: ...
def get_stop_details(state: State) -> object: ...
def symbolic_register_data(state: State, count: int, offsets: Sequence[int]) -> None: ...
def get_symbolic_registers(state: State, output: Sequence[int]) -> int: ...
def enable_symbolic_reg_tracking(state: State, guest: int, archinfo: int) -> None: ...
def disable_symbolic_reg_tracking(state: State) -> None: ...
def is_interrupt_handled(state: State) -> bool: ...
def set_cgc_syscall_details(
    state: State,
    transmit_num: int,
    transmit_bbl: int,
    receive_num: int,
    receive_bbl: int,
    receive_size: int,
    random_num: int,
    random_bbl: int,
) -> None: ...
def process_transmit(state: State, num: int) -> object: ...
def set_fd_bytes(state: State, fd: int, input: bytes, taints: bytes, len: int, read_pos: int) -> None: ...
def cache_page(state: State, address: int, length: int, bytes: bytes, permissions: int) -> bool: ...
def uncache_pages_touching_region(state: State, address: int, length: int) -> None: ...
def clear_page_cache(state: State) -> None: ...
def set_tracking(state: State, track_bbls: bool, track_stack: bool) -> None: ...
def in_cache(state: State, address: int) -> bool: ...
def set_map_callback(state: State, cb: object) -> None: ...
def set_artificial_registers(state: State, offsets: Sequence[int], count: int) -> None: ...
def set_vex_to_unicorn_reg_mappings(
    state: State, vex_offsets: Sequence[int], unicorn_ids: Sequence[int], reg_sizes: Sequence[int], count: int
) -> None: ...
def set_cpu_flags_details(
    state: State, flag_vex_id: Sequence[int], uc_reg_id: Sequence[int], bitmasks: Sequence[int], count: int
) -> None: ...
def set_register_blacklist(state: State, reg_list: Sequence[int], count: int) -> None: ...
def set_vex_cc_reg_data(state: State, reg_offsets: Sequence[int], reg_sizes: Sequence[int], count: int) -> None: ...
def get_count_of_blocks_with_symbolic_vex_stmts(state: State) -> int: ...
def get_details_of_blocks_with_symbolic_vex_stmts(state: State, ret_block_details: object) -> None: ...
def get_count_of_writes_to_reexecute(state: State) -> int: ...
def get_concrete_writes_to_reexecute(state: State, addrs: Sequence[int], values: bytes) -> None: ...
def set_fp_regs_fp_ops_vex_codes(
    state: State, start_offset: int, size: int, ops: Sequence[int], op_count: int
) -> None: ...
